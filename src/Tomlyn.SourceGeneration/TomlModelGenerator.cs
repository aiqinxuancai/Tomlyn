using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Tomlyn.SourceGeneration;

[Generator]
public sealed class TomlModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var modelTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Tomlyn.TomlModelAttribute",
                static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                static (ctx, _) => ctx.TargetSymbol)
            .Collect();

        context.RegisterSourceOutput(modelTypes, static (spc, types) => Execute(spc, types));
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<ISymbol> types)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        var allTypes = new Dictionary<INamedTypeSymbol, ModelInfo>(SymbolEqualityComparer.Default);
        foreach (var symbol in types.Distinct(SymbolEqualityComparer.Default))
        {
            if (symbol is INamedTypeSymbol type)
            {
                CollectTypes(type, allTypes);
            }
        }

        if (allTypes.Count == 0)
        {
            return;
        }

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine("using System.Diagnostics.CodeAnalysis;");
        builder.AppendLine("using Tomlyn;");
        builder.AppendLine("using Tomlyn.Model;");
        builder.AppendLine("using Tomlyn.Syntax;");
        builder.AppendLine();
        builder.AppendLine("namespace Tomlyn.Generated");
        builder.AppendLine("{");

        foreach (var entry in allTypes.Values.OrderBy(m => m.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
        {
            EmitModel(builder, entry);
        }

        builder.AppendLine("    internal static class TomlGeneratedModelReaders");
        builder.AppendLine("    {");
        foreach (var entry in allTypes.Values.OrderBy(m => m.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
        {
            EmitReadMethod(builder, entry);
        }
        builder.AppendLine("    }");

        builder.AppendLine("    internal static class TomlGeneratedModelRegistration");
        builder.AppendLine("    {");
        builder.AppendLine("        [ModuleInitializer]");
        builder.AppendLine("        internal static void Register()");
        builder.AppendLine("        {");
        foreach (var entry in allTypes.Values.OrderBy(m => m.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
        {
            builder.Append("            TomlGeneratedModelRegistry.Register(new ")
                .Append(GetGeneratedModelName(entry.Type))
                .AppendLine("());");
        }
        builder.AppendLine("        }");
        builder.AppendLine("    }");

        builder.AppendLine("}");

        context.AddSource("TomlGeneratedModels.g.cs", builder.ToString());
    }

    private static void CollectTypes(INamedTypeSymbol type, Dictionary<INamedTypeSymbol, ModelInfo> allTypes)
    {
        if (type.TypeKind is not (TypeKind.Class or TypeKind.Struct))
        {
            return;
        }

        if (allTypes.ContainsKey(type))
        {
            return;
        }

        var model = new ModelInfo(type);
        allTypes.Add(type, model);

        foreach (var member in type.GetMembers())
        {
            if (member is IPropertySymbol property)
            {
                if (property.IsIndexer || property.DeclaredAccessibility != Accessibility.Public)
                {
                    continue;
                }

                if (HasIgnoreAttribute(property))
                {
                    continue;
                }

                var baseName = GetTomlBaseName(property);
                if (baseName is null)
                {
                    continue;
                }

                var defaultKey = PascalToSnakeCase(baseName);
                var propertyInfo = new MemberInfo(property, baseName, defaultKey);
                model.Properties.Add(propertyInfo);

                foreach (var nested in GetReferencedModelTypes(property.Type))
                {
                    CollectTypes(nested, allTypes);
                }

                continue;
            }

            if (member is IFieldSymbol field)
            {
                if (field.IsStatic || field.IsConst || field.DeclaredAccessibility != Accessibility.Public)
                {
                    continue;
                }

                if (field.IsReadOnly && (field.Type.IsValueType || IsString(field.Type)))
                {
                    continue;
                }

                if (HasIgnoreAttribute(field))
                {
                    continue;
                }

                var baseName = GetTomlBaseName(field);
                if (baseName is null)
                {
                    continue;
                }

                var defaultKey = PascalToSnakeCase(baseName);
                var fieldInfo = new MemberInfo(field, baseName, defaultKey);
                model.Fields.Add(fieldInfo);

                foreach (var nested in GetReferencedModelTypes(field.Type))
                {
                    CollectTypes(nested, allTypes);
                }
            }
        }
    }

    private static IEnumerable<INamedTypeSymbol> GetReferencedModelTypes(ITypeSymbol type)
    {
        var target = UnwrapNullable(type);
        if (target is IArrayTypeSymbol arrayType)
        {
            target = arrayType.ElementType;
        }

        if (TryGetDictionaryTypes(target, out var _, out var valueType))
        {
            target = valueType;
        }
        else if (TryGetEnumerableElementType(target, out var elementType))
        {
            target = elementType;
        }

        if (target is INamedTypeSymbol named && IsModelCandidate(named))
        {
            yield return named;
        }
    }

    private static bool IsModelCandidate(INamedTypeSymbol type)
    {
        if (type.TypeKind is not (TypeKind.Class or TypeKind.Struct))
        {
            return false;
        }

        if (type.SpecialType != SpecialType.None)
        {
            return false;
        }

        if (type.ContainingNamespace?.ToDisplayString().StartsWith("System", StringComparison.Ordinal) == true)
        {
            return false;
        }

        return true;
    }

    private static bool IsGeneratedModelType(ITypeSymbol type)
    {
        return type is INamedTypeSymbol named && IsModelCandidate(named);
    }

    private static void EmitModel(StringBuilder builder, ModelInfo model)
    {
        var typeName = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var generatedName = GetGeneratedModelName(model.Type);
        builder.Append("    internal sealed class ")
            .Append(generatedName)
            .Append(" : ITomlGeneratedModel<")
            .Append(typeName)
            .AppendLine(">");
        builder.AppendLine("    {");
        builder.Append("        public Type TargetType => typeof(")
            .Append(typeName)
            .AppendLine(");");
        builder.AppendLine();
        builder.Append("        public bool TryRead(TomlTable table, [NotNullWhen(true)] out ")
            .Append(typeName)
            .Append("? model, out DiagnosticsBag diagnostics, TomlModelOptions? options = null)");
        builder.AppendLine();
        builder.AppendLine("        {");
        builder.AppendLine("            diagnostics = new DiagnosticsBag();");
        builder.Append("            var result = new ")
            .Append(typeName)
            .AppendLine("();");
        builder.Append("            var ok = TomlGeneratedModelReaders.Read_")
            .Append(GetSafeTypeName(model.Type))
            .AppendLine("(table, result, diagnostics, options);");
        builder.AppendLine("            model = ok ? result : null;");
        builder.AppendLine("            return ok;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.Append("        bool ITomlGeneratedModel.TryRead(TomlTable table, [NotNullWhen(true)] out object? model, out DiagnosticsBag diagnostics, TomlModelOptions? options)");
        builder.AppendLine();
        builder.AppendLine("        {");
        builder.Append("            var ok = TryRead(table, out ")
            .Append(typeName)
            .AppendLine("? typed, out diagnostics, options);");
        builder.AppendLine("            model = typed;");
        builder.AppendLine("            return ok;");
        builder.AppendLine("        }");
        builder.AppendLine("    }");
        builder.AppendLine();
    }

    private static void EmitReadMethod(StringBuilder builder, ModelInfo model)
    {
        var typeName = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var keyEntries = model.Properties
            .Select(prop => new { Member = prop, KeyVar = "key_" + GetSafeIdentifier(prop.MemberName) })
            .ToList();
        var fieldEntries = model.Fields
            .Select(field => new { Member = field, KeyVar = "field_" + GetSafeIdentifier(field.MemberName) })
            .ToList();
        builder.Append("        internal static bool Read_")
            .Append(GetSafeTypeName(model.Type))
            .Append("(TomlTable table, ")
            .Append(typeName)
            .Append(" target, DiagnosticsBag diagnostics, TomlModelOptions? options)");
        builder.AppendLine();
        builder.AppendLine("        {");
        builder.AppendLine("            var ok = true;");

        foreach (var entry in keyEntries)
        {
            var baseNameLiteral = EscapeStringLiteral(entry.Member.BaseName);
            var defaultKeyLiteral = EscapeStringLiteral(entry.Member.DefaultKey);
            builder.Append("            var ")
                .Append(entry.KeyVar)
                .Append(" = options is null ? \"")
                .Append(defaultKeyLiteral)
                .Append("\" : options.ConvertPropertyName(\"")
                .Append(baseNameLiteral)
                .AppendLine("\");");
        }

        foreach (var entry in fieldEntries)
        {
            var baseNameLiteral = EscapeStringLiteral(entry.Member.BaseName);
            var defaultKeyLiteral = EscapeStringLiteral(entry.Member.DefaultKey);
            builder.Append("            var ")
                .Append(entry.KeyVar)
                .Append(" = options is null ? \"")
                .Append(defaultKeyLiteral)
                .Append("\" : options.ConvertFieldName(\"")
                .Append(baseNameLiteral)
                .AppendLine("\");");
        }

        if (keyEntries.Count > 0 || fieldEntries.Count > 0)
        {
            builder.AppendLine();
            builder.AppendLine("            if (options?.IgnoreMissingProperties != true)");
            builder.AppendLine("            {");
            builder.AppendLine("                var knownKeys = new HashSet<string>(StringComparer.Ordinal)");
            builder.AppendLine("                {");
            foreach (var entry in keyEntries)
            {
                builder.Append("                    ")
                    .Append(entry.KeyVar)
                    .AppendLine(",");
            }
            builder.AppendLine("                };");
            if (fieldEntries.Count > 0)
            {
                builder.AppendLine("                if (options?.IncludeFields == true)");
                builder.AppendLine("                {");
                foreach (var entry in fieldEntries)
                {
                    builder.Append("                    knownKeys.Add(")
                        .Append(entry.KeyVar)
                        .AppendLine(");");
                }
                builder.AppendLine("                }");
            }
            builder.AppendLine("                foreach (var entry in table)");
            builder.AppendLine("                {");
            builder.AppendLine("                    if (!knownKeys.Contains(entry.Key))");
            builder.AppendLine("                    {");
            builder.Append("                        diagnostics.Error(default, $\"The property `{entry.Key}` was not found on object type {typeof(")
                .Append(typeName)
                .AppendLine(").FullName}\");");
            builder.AppendLine("                        ok = false;");
            builder.AppendLine("                    }");
            builder.AppendLine("                }");
            builder.AppendLine("            }");
        }

        foreach (var entry in keyEntries)
        {
            EmitMemberRead(builder, entry.Member, entry.KeyVar);
        }

        if (fieldEntries.Count > 0)
        {
            builder.AppendLine();
            builder.AppendLine("            if (options?.IncludeFields == true)");
            builder.AppendLine("            {");
            foreach (var entry in fieldEntries)
            {
                EmitMemberRead(builder, entry.Member, entry.KeyVar, indent: "                ");
            }
            builder.AppendLine("            }");
        }

        builder.AppendLine("            return ok;");
        builder.AppendLine("        }");
        builder.AppendLine();
    }

    private static void EmitMemberRead(StringBuilder builder, MemberInfo member, string keyVar, string indent = "            ")
    {
        var memberType = member.MemberType;
        var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var valueVar = "value_" + GetSafeIdentifier(member.MemberName);

        builder.Append(indent)
            .Append("if (table.TryGetValue(")
            .Append(keyVar)
            .Append(", out var ")
            .Append(valueVar)
            .AppendLine("))");
        builder.Append(indent)
            .AppendLine("{");

        const string spanCall = "default";

        if (TryGetDictionaryTypes(memberType, out var keyType, out var valueType))
        {
            EmitDictionaryRead(builder, member, memberType, keyType, valueType, spanCall, valueVar, keyVar);
        }
        else if (TryGetEnumerableElementType(memberType, out var elementType))
        {
            EmitListRead(builder, member, memberType, elementType, spanCall, valueVar, keyVar);
        }
        else if (memberType is IArrayTypeSymbol arrayType)
        {
            EmitArrayRead(builder, member, arrayType.ElementType, spanCall, valueVar, keyVar);
        }
        else if (IsPrimitive(memberType))
        {
            EmitPrimitiveRead(builder, member, memberTypeName, spanCall, valueVar, keyVar);
        }
        else
        {
            EmitObjectRead(builder, member, memberType, spanCall, valueVar, keyVar);
        }

        builder.Append(indent)
            .AppendLine("}");
    }

    private static void EmitPrimitiveRead(StringBuilder builder, MemberInfo member, string memberTypeName, string spanCall, string valueVar, string keyVar)
    {
        builder.Append("                if (TomlModelConversion.TryConvert(")
            .Append(valueVar)
            .Append(", typeof(")
            .Append(memberTypeName)
            .AppendLine("), options, out var converted) && converted is ");
        builder.Append(memberTypeName).AppendLine(" typed)");
        builder.AppendLine("                {");
        EmitSetValue(builder, member, "typed", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.AppendLine("                else");
        builder.AppendLine("                {");
        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Unable to convert property '{")
            .Append(keyVar)
            .Append("}' to ")
            .Append(memberTypeName.Replace("\"", "\\\""))
            .AppendLine(".\");");
        builder.AppendLine("                    ok = false;");
        builder.AppendLine("                }");
    }

    private static void EmitObjectRead(StringBuilder builder, MemberInfo member, ITypeSymbol memberType, string spanCall, string valueVar, string keyVar)
    {
        var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var canConstruct = HasPublicParameterlessCtor(memberType);
        var isModelType = IsGeneratedModelType(memberType);

        if (!isModelType)
        {
            EmitPrimitiveRead(builder, member, memberTypeName, spanCall, valueVar, keyVar);
            return;
        }
        builder.Append("                if (")
            .Append(valueVar)
            .Append(" is TomlTable nestedTable)");
        builder.AppendLine();
        builder.AppendLine("                {");
        if (canConstruct)
        {
            builder.Append("                    var nested = new ")
                .Append(memberTypeName)
                .AppendLine("();");
            builder.Append("                    if (!Read_")
                .Append(GetSafeTypeName(memberType))
                .AppendLine("(nestedTable, nested, diagnostics, options))");
            builder.AppendLine("                    {");
            builder.AppendLine("                        ok = false;");
            builder.AppendLine("                    }");
            EmitSetValue(builder, member, "nested", spanCall, keyVar);
        }
        else
        {
            builder.Append("                    diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Type '{typeof(")
                .Append(memberTypeName)
                .AppendLine(").FullName}' must have a public parameterless constructor.\");");
            builder.AppendLine("                    ok = false;");
        }
        builder.AppendLine("                }");
        builder.Append("                else if (TomlModelConversion.TryConvert(")
            .Append(valueVar)
            .Append(", typeof(")
            .Append(memberTypeName)
            .AppendLine("), options, out var converted) && converted is ");
        builder.Append(memberTypeName).AppendLine(" typed)");
        builder.AppendLine("                {");
        EmitSetValue(builder, member, "typed", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.AppendLine("                else");
        builder.AppendLine("                {");
        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Expected table for '{")
            .Append(keyVar)
            .AppendLine("}'.\");");
        builder.AppendLine("                    ok = false;");
        builder.AppendLine("                }");
    }

    private static void EmitListRead(StringBuilder builder, MemberInfo member, ITypeSymbol memberType, ITypeSymbol elementType, string spanCall, string valueVar, string keyVar)
    {
        var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var memberTypeNamed = memberType as INamedTypeSymbol;
        var isInterfaceOrAbstract = memberTypeNamed is { TypeKind: TypeKind.Interface } || memberTypeNamed?.IsAbstract == true;
        var canConstruct = HasPublicParameterlessCtor(memberType);
        var hasSetter = member.CanWrite;
        var hasGetter = member.HasGetter;
        var useExisting = !hasSetter || (!isInterfaceOrAbstract && !canConstruct);

        if (useExisting)
        {
            if (!hasGetter)
            {
                builder.Append("                diagnostics.Error(")
                    .Append(spanCall)
                    .Append(", $\"Property '{")
                    .Append(keyVar)
                    .AppendLine("}' does not have a getter for collection population.\");");
                builder.AppendLine("                ok = false;");
                return;
            }

            builder.Append("                var list = target.")
                .Append(member.MemberName)
                .AppendLine(";");
            builder.AppendLine("                if (list is null)");
            builder.AppendLine("                {");
            builder.Append("                    diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Property '{")
                .Append(keyVar)
                .AppendLine("}' is null and cannot be populated.\");");
            builder.AppendLine("                    ok = false;");
            builder.AppendLine("                }");
            builder.AppendLine("                else");
            builder.AppendLine("                {");
        EmitListPopulation(builder, elementType, elementTypeName, spanCall, valueVar, keyVar, "list");
            builder.AppendLine("                }");
            return;
        }

        var createType = isInterfaceOrAbstract
            ? $"System.Collections.Generic.List<{elementTypeName}>"
            : memberTypeName;

        builder.Append("                if (")
            .Append(valueVar)
            .AppendLine(" is TomlTableArray tableArray)");
        builder.AppendLine("                {");
        builder.Append("                    var list = new ")
            .Append(createType)
            .AppendLine("();");
        EmitListPopulationTableArray(builder, elementType, elementTypeName, spanCall, keyVar, "list");
        EmitSetValue(builder, member, "list", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.Append("                else if (")
            .Append(valueVar)
            .AppendLine(" is TomlArray array)");
        builder.AppendLine("                {");
        builder.Append("                    var list = new ")
            .Append(createType)
            .AppendLine("();");
        EmitListPopulationArray(builder, elementType, elementTypeName, spanCall, keyVar, "list");
        EmitSetValue(builder, member, "list", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.AppendLine("                else");
        builder.AppendLine("                {");
        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Expected array for '{")
            .Append(keyVar)
            .AppendLine("}'.\");");
        builder.AppendLine("                    ok = false;");
        builder.AppendLine("                }");
    }
    private static void EmitArrayRead(StringBuilder builder, MemberInfo member, ITypeSymbol elementType, string spanCall, string valueVar, string keyVar)
    {
        var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        builder.Append("                if (")
            .Append(valueVar)
            .AppendLine(" is TomlTableArray tableArray)");
        builder.AppendLine("                {");
        builder.Append("                    var list = new List<")
            .Append(elementTypeName)
            .AppendLine(">();");
        EmitListPopulationTableArray(builder, elementType, elementTypeName, spanCall, keyVar, "list");
        builder.AppendLine("                    var arrayValue = list.ToArray();");
        EmitSetValue(builder, member, "arrayValue", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.Append("                else if (")
            .Append(valueVar)
            .AppendLine(" is TomlArray array)");
        builder.AppendLine("                {");
        builder.Append("                    var list = new List<")
            .Append(elementTypeName)
            .AppendLine(">();");
        EmitListPopulationArray(builder, elementType, elementTypeName, spanCall, keyVar, "list");
        builder.AppendLine("                    var arrayValue = list.ToArray();");
        EmitSetValue(builder, member, "arrayValue", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.AppendLine("                else");
        builder.AppendLine("                {");
        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Expected array for '{")
            .Append(keyVar)
            .AppendLine("}'.\");");
        builder.AppendLine("                    ok = false;");
        builder.AppendLine("                }");
    }

    private static void EmitListPopulation(StringBuilder builder, ITypeSymbol elementType, string elementTypeName, string spanCall, string valueVar, string keyVar, string listVar)
    {
        builder.Append("                    if (")
            .Append(valueVar)
            .AppendLine(" is TomlTableArray tableArray)");
        builder.AppendLine("                    {");
        EmitListPopulationTableArray(builder, elementType, elementTypeName, spanCall, keyVar, listVar);
        builder.AppendLine("                    }");
        builder.Append("                    else if (")
            .Append(valueVar)
            .AppendLine(" is TomlArray array)");
        builder.AppendLine("                    {");
        EmitListPopulationArray(builder, elementType, elementTypeName, spanCall, keyVar, listVar);
        builder.AppendLine("                    }");
        builder.AppendLine("                    else");
        builder.AppendLine("                    {");
        builder.Append("                        diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Expected array for '{")
            .Append(keyVar)
            .AppendLine("}'.\");");
        builder.AppendLine("                        ok = false;");
        builder.AppendLine("                    }");
    }

    private static void EmitListPopulationTableArray(StringBuilder builder, ITypeSymbol elementType, string elementTypeName, string spanCall, string keyVar, string listVar)
    {
        var canConstructElement = HasPublicParameterlessCtor(elementType);
        var isModelElement = IsGeneratedModelType(elementType);
        builder.AppendLine("                        foreach (var item in tableArray)");
        builder.AppendLine("                        {");
        if (IsPrimitive(elementType) || !isModelElement)
        {
            builder.Append("                            if (TomlModelConversion.TryConvert(item, typeof(")
                .Append(elementTypeName)
                .AppendLine("), options, out var converted) && converted is ");
            builder.Append(elementTypeName).AppendLine(" typed)");
            builder.AppendLine("                            {");
            builder.Append("                                ")
                .Append(listVar)
                .AppendLine(".Add(typed);");
            builder.AppendLine("                            }");
            builder.AppendLine("                            else");
            builder.AppendLine("                            {");
            builder.Append("                                diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Unable to convert array element for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                                ok = false;");
            builder.AppendLine("                            }");
        }
        else if (canConstructElement)
        {
            builder.AppendLine("                            if (item is TomlTable itemTable)");
            builder.AppendLine("                            {");
            builder.Append("                                var nested = new ")
                .Append(elementTypeName)
                .AppendLine("();");
            builder.Append("                                if (!Read_")
                .Append(GetSafeTypeName(elementType))
                .AppendLine("(itemTable, nested, diagnostics, options))");
            builder.AppendLine("                                {");
            builder.AppendLine("                                    ok = false;");
            builder.AppendLine("                                }");
            builder.Append("                                ")
                .Append(listVar)
                .AppendLine(".Add(nested);");
            builder.AppendLine("                            }");
            builder.AppendLine("                            else");
            builder.AppendLine("                            {");
            builder.Append("                                diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Expected table array element for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                                ok = false;");
            builder.AppendLine("                            }");
        }
        else
        {
            builder.Append("                            diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Type '{typeof(")
                .Append(elementTypeName)
                .AppendLine(").FullName}' must have a public parameterless constructor.\");");
            builder.AppendLine("                            ok = false;");
        }
        builder.AppendLine("                        }");
    }

    private static void EmitListPopulationArray(StringBuilder builder, ITypeSymbol elementType, string elementTypeName, string spanCall, string keyVar, string listVar)
    {
        var canConstructElement = HasPublicParameterlessCtor(elementType);
        var isModelElement = IsGeneratedModelType(elementType);
        builder.AppendLine("                        foreach (var item in array)");
        builder.AppendLine("                        {");
        if (!IsPrimitive(elementType) && isModelElement)
        {
            builder.AppendLine("                            if (item is TomlTable itemTable)");
            builder.AppendLine("                            {");
            if (canConstructElement)
            {
                builder.Append("                                var nested = new ")
                    .Append(elementTypeName)
                    .AppendLine("();");
                builder.Append("                                if (!Read_")
                    .Append(GetSafeTypeName(elementType))
                    .AppendLine("(itemTable, nested, diagnostics, options))");
                builder.AppendLine("                                {");
                builder.AppendLine("                                    ok = false;");
                builder.AppendLine("                                }");
                builder.Append("                                ")
                    .Append(listVar)
                    .AppendLine(".Add(nested);");
                builder.AppendLine("                                continue;");
            }
            else
            {
                builder.Append("                                diagnostics.Error(")
                    .Append(spanCall)
                    .Append(", $\"Type '{typeof(")
                    .Append(elementTypeName)
                    .AppendLine(").FullName}' must have a public parameterless constructor.\");");
                builder.AppendLine("                                ok = false;");
                builder.AppendLine("                                continue;");
            }
            builder.AppendLine("                            }");
        }
        builder.Append("                            if (TomlModelConversion.TryConvert(item, typeof(")
            .Append(elementTypeName)
            .AppendLine("), options, out var converted) && converted is ");
        builder.Append(elementTypeName).AppendLine(" typed)");
        builder.AppendLine("                            {");
        builder.Append("                                ")
            .Append(listVar)
            .AppendLine(".Add(typed);");
        builder.AppendLine("                            }");
        builder.AppendLine("                            else");
        builder.AppendLine("                            {");
            builder.Append("                                diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Unable to convert array element for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                                ok = false;");
        builder.AppendLine("                            }");
        builder.AppendLine("                        }");
    }

    private static void EmitDictionaryPopulation(StringBuilder builder, ITypeSymbol keyType, string keyTypeName, ITypeSymbol valueType, string valueTypeName, string spanCall, string tableVar, string keyVar, string dictVar)
    {
        var canConstructValue = HasPublicParameterlessCtor(valueType);
        var isModelValue = IsGeneratedModelType(valueType);
        builder.AppendLine("                    foreach (var entry in " + tableVar + ")");
        builder.AppendLine("                    {");

        if (IsString(keyType))
        {
            builder.AppendLine("                        var typedKey = entry.Key;");
        }
        else
        {
            builder.Append("                        if (!TomlModelConversion.TryConvert(entry.Key, typeof(")
                .Append(keyTypeName)
                .AppendLine("), options, out var keyConverted) || keyConverted is not ");
            builder.Append(keyTypeName).AppendLine(" typedKey)");
            builder.AppendLine("                        {");
            builder.Append("                            diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Unable to convert map key for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                            ok = false;");
            builder.AppendLine("                            continue;");
            builder.AppendLine("                        }");
        }

        if (IsPrimitive(valueType) || !isModelValue)
        {
            builder.Append("                        if (TomlModelConversion.TryConvert(entry.Value, typeof(")
                .Append(valueTypeName)
                .AppendLine("), options, out var converted) && converted is ");
            builder.Append(valueTypeName).AppendLine(" typed)");
            builder.AppendLine("                        {");
            builder.Append("                            ")
                .Append(dictVar)
                .AppendLine("[typedKey] = typed;");
            builder.AppendLine("                        }");
            builder.AppendLine("                        else");
            builder.AppendLine("                        {");
            builder.Append("                            diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Unable to convert map value for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                            ok = false;");
            builder.AppendLine("                        }");
        }
        else if (canConstructValue)
        {
            builder.AppendLine("                        if (entry.Value is TomlTable entryTable)");
            builder.AppendLine("                        {");
            builder.Append("                            var nested = new ")
                .Append(valueTypeName)
                .AppendLine("();");
            builder.Append("                            if (!Read_")
                .Append(GetSafeTypeName(valueType))
                .AppendLine("(entryTable, nested, diagnostics, options))");
            builder.AppendLine("                            {");
            builder.AppendLine("                                ok = false;");
            builder.AppendLine("                            }");
            builder.Append("                            ")
                .Append(dictVar)
                .AppendLine("[typedKey] = nested;");
            builder.AppendLine("                        }");
            builder.AppendLine("                        else");
            builder.AppendLine("                        {");
            builder.Append("                            diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Expected table for map value '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                            ok = false;");
            builder.AppendLine("                        }");
        }
        else
        {
            builder.Append("                        diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Type '{typeof(")
                .Append(valueTypeName)
                .AppendLine(").FullName}' must have a public parameterless constructor.\");");
            builder.AppendLine("                        ok = false;");
        }

        builder.AppendLine("                    }");
    }

    private static void EmitDictionaryRead(StringBuilder builder, MemberInfo member, ITypeSymbol memberType, ITypeSymbol keyType, ITypeSymbol valueType, string spanCall, string valueVar, string keyVar)
    {
        var keyTypeName = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var valueTypeName = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var memberTypeName = memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var memberTypeNamed = memberType as INamedTypeSymbol;
        var isInterfaceOrAbstract = memberTypeNamed is { TypeKind: TypeKind.Interface } || memberTypeNamed?.IsAbstract == true;
        var canConstruct = HasPublicParameterlessCtor(memberType);
        var hasSetter = member.CanWrite;
        var hasGetter = member.HasGetter;
        var useExisting = !hasSetter || (!isInterfaceOrAbstract && !canConstruct);

        if (useExisting)
        {
            if (!hasGetter)
            {
                builder.Append("                diagnostics.Error(")
                    .Append(spanCall)
                    .Append(", $\"Property '{")
                    .Append(keyVar)
                    .AppendLine("}' does not have a getter for dictionary population.\");");
                builder.AppendLine("                ok = false;");
                return;
            }

            builder.Append("                var dict = target.")
                .Append(member.MemberName)
                .AppendLine(";");
            builder.AppendLine("                if (dict is null)");
            builder.AppendLine("                {");
            builder.Append("                    diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Property '{")
                .Append(keyVar)
                .AppendLine("}' is null and cannot be populated.\");");
            builder.AppendLine("                    ok = false;");
            builder.AppendLine("                }");
            builder.AppendLine("                else");
            builder.AppendLine("                {");
            builder.Append("                    if (")
                .Append(valueVar)
                .AppendLine(" is TomlTable mapTable)");
            builder.AppendLine("                    {");
            EmitDictionaryPopulation(builder, keyType, keyTypeName, valueType, valueTypeName, spanCall, "mapTable", keyVar, "dict");
            builder.AppendLine("                    }");
            builder.AppendLine("                    else");
            builder.AppendLine("                    {");
            builder.Append("                        diagnostics.Error(")
                .Append(spanCall)
                .Append(", $\"Expected table for '{")
                .Append(keyVar)
                .AppendLine("}'.\");");
            builder.AppendLine("                        ok = false;");
            builder.AppendLine("                    }");
            builder.AppendLine("                }");
            return;
        }

        var createType = isInterfaceOrAbstract
            ? $"System.Collections.Generic.Dictionary<{keyTypeName}, {valueTypeName}>"
            : memberTypeName;

        builder.Append("                if (")
            .Append(valueVar)
            .AppendLine(" is TomlTable mapTable)");
        builder.AppendLine("                {");
        builder.Append("                    var dict = new ")
            .Append(createType)
            .AppendLine("();");
        EmitDictionaryPopulation(builder, keyType, keyTypeName, valueType, valueTypeName, spanCall, "mapTable", keyVar, "dict");
        EmitSetValue(builder, member, "dict", spanCall, keyVar);
        builder.AppendLine("                }");
        builder.AppendLine("                else");
        builder.AppendLine("                {");
        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Expected table for '{")
            .Append(keyVar)
            .AppendLine("}'.\");");
        builder.AppendLine("                    ok = false;");
        builder.AppendLine("                }");
    }

    private static void EmitSetValue(StringBuilder builder, MemberInfo member, string valueExpression, string spanCall, string keyVar)
    {
        if (member.CanWrite)
        {
            builder.Append("                    target.")
                .Append(member.MemberName)
                .Append(" = ")
                .Append(valueExpression)
                .AppendLine(";");
            return;
        }

        builder.Append("                    diagnostics.Error(")
            .Append(spanCall)
            .Append(", $\"Member '{")
            .Append(keyVar)
            .AppendLine("}' is read-only.\");");
        builder.AppendLine("                    ok = false;");
    }

    private static bool HasIgnoreAttribute(ISymbol symbol)
    {
        foreach (var attribute in symbol.GetAttributes())
        {
            var fullName = attribute.AttributeClass?.ToDisplayString();
            if (fullName == "System.Runtime.Serialization.IgnoreDataMemberAttribute" ||
                fullName == "System.Text.Json.Serialization.JsonIgnoreAttribute")
            {
                return true;
            }
        }

        return false;
    }

    private static string? GetTomlBaseName(ISymbol symbol)
    {
        foreach (var attribute in symbol.GetAttributes())
        {
            var fullName = attribute.AttributeClass?.ToDisplayString();
            if (fullName == "Tomlyn.TomlPropertyNameAttribute")
            {
                if (attribute.ConstructorArguments.Length == 1 && attribute.ConstructorArguments[0].Value is string tomlName)
                {
                    return tomlName;
                }

                foreach (var pair in attribute.NamedArguments)
                {
                    if (pair.Key == "Name" && pair.Value.Value is string tomlNamed && !string.IsNullOrWhiteSpace(tomlNamed))
                    {
                        return tomlNamed;
                    }
                }
            }
            else if (fullName == "System.Runtime.Serialization.DataMemberAttribute")
            {
                foreach (var pair in attribute.NamedArguments)
                {
                    if (pair.Key == "Name" && pair.Value.Value is string dataName && !string.IsNullOrWhiteSpace(dataName))
                    {
                        return dataName;
                    }
                }
            }
            else if (fullName == "System.Text.Json.Serialization.JsonPropertyNameAttribute")
            {
                if (attribute.ConstructorArguments.Length == 1 && attribute.ConstructorArguments[0].Value is string jsonName)
                {
                    return jsonName;
                }

                foreach (var pair in attribute.NamedArguments)
                {
                    if (pair.Key == "Name" && pair.Value.Value is string jsonNamed && !string.IsNullOrWhiteSpace(jsonNamed))
                    {
                        return jsonNamed;
                    }
                }
            }
        }

        return symbol.Name;
    }

    private static string PascalToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }

        var builder = new StringBuilder(name.Length + 8);
        var previous = '\0';
        foreach (var c in name)
        {
            if (char.IsUpper(c) && !char.IsUpper(previous) && previous != '\0' && previous != '_')
            {
                builder.Append('_');
            }

            builder.Append(char.ToLowerInvariant(c));
            previous = c;
        }

        return builder.ToString();
    }

    private static string GetGeneratedModelName(INamedTypeSymbol type)
    {
        return "TomlGeneratedModel_" + GetSafeTypeName(type);
    }

    private static string GetSafeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return "member";
        }

        var builder = new StringBuilder(name.Length + 4);
        var first = name[0];
        if (!char.IsLetter(first) && first != '_')
        {
            builder.Append('_');
        }

        foreach (var c in name)
        {
            builder.Append(char.IsLetterOrDigit(c) || c == '_' ? c : '_');
        }

        return builder.ToString();
    }

    private static string EscapeStringLiteral(string value)
    {
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static bool HasPublicParameterlessCtor(ITypeSymbol type)
    {
        if (type.TypeKind == TypeKind.Struct)
        {
            return true;
        }

        if (type is INamedTypeSymbol named)
        {
            foreach (var ctor in named.InstanceConstructors)
            {
                if (ctor.Parameters.Length == 0 && ctor.DeclaredAccessibility == Accessibility.Public)
                {
                    return true;
                }
            }
        }

        return false;
    }

    private static string GetSafeTypeName(ITypeSymbol type)
    {
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty)
            .Replace(".", "_")
            .Replace("+", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_");
        return name;
    }

    private static bool IsPrimitive(ITypeSymbol type)
    {
        var unwrapped = UnwrapNullable(type);
        if (unwrapped.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (unwrapped.SpecialType != SpecialType.None)
        {
            return unwrapped.SpecialType switch
            {
                SpecialType.System_String => true,
                SpecialType.System_Boolean => true,
                SpecialType.System_Char => true,
                SpecialType.System_SByte => true,
                SpecialType.System_Byte => true,
                SpecialType.System_Int16 => true,
                SpecialType.System_UInt16 => true,
                SpecialType.System_Int32 => true,
                SpecialType.System_UInt32 => true,
                SpecialType.System_Int64 => true,
                SpecialType.System_UInt64 => true,
                SpecialType.System_Single => true,
                SpecialType.System_Double => true,
                SpecialType.System_Decimal => true,
                _ => false
            };
        }

        var name = unwrapped.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return name == "global::System.DateTime" ||
               name == "global::System.DateTimeOffset" ||
               name == "global::Tomlyn.TomlDateTime" ||
               name == "global::System.DateOnly" ||
               name == "global::System.TimeOnly";
    }

    private static bool IsString(ITypeSymbol type)
    {
        var unwrapped = UnwrapNullable(type);
        return unwrapped.SpecialType == SpecialType.System_String;
    }

    private static ITypeSymbol UnwrapNullable(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol named && named.IsGenericType && named.ConstructedFrom?.SpecialType == SpecialType.System_Nullable_T)
        {
            return named.TypeArguments[0];
        }

        return type;
    }

    private static bool TryGetEnumerableElementType(ITypeSymbol type, out ITypeSymbol elementType)
    {
        elementType = null!;
        var unwrapped = UnwrapNullable(type);
        if (IsString(unwrapped))
        {
            return false;
        }
        if (unwrapped is IArrayTypeSymbol)
        {
            return false;
        }

        if (unwrapped is INamedTypeSymbol named && named.IsGenericType)
        {
            if (IsKnownListDefinition(named.ConstructedFrom))
            {
                elementType = named.TypeArguments[0];
                return true;
            }
        }

        foreach (var iface in unwrapped.AllInterfaces)
        {
            if (iface is INamedTypeSymbol ifaceNamed && ifaceNamed.IsGenericType &&
                ifaceNamed.ConstructedFrom.Name == "ICollection" &&
                ifaceNamed.ConstructedFrom.ContainingNamespace.ToDisplayString() == "System.Collections.Generic")
            {
                elementType = ifaceNamed.TypeArguments[0];
                return true;
            }
        }

        return false;
    }

    private static bool IsKnownListDefinition(INamedTypeSymbol type)
    {
        if (type.ContainingNamespace.ToDisplayString() != "System.Collections.Generic")
        {
            return false;
        }

        return type.Name is "List" or "IList" or "ICollection";
    }

    private static bool TryGetDictionaryTypes(ITypeSymbol type, out ITypeSymbol keyType, out ITypeSymbol valueType)
    {
        keyType = null!;
        valueType = null!;
        var unwrapped = UnwrapNullable(type);
        foreach (var iface in unwrapped.AllInterfaces)
        {
            if (iface is INamedTypeSymbol ifaceNamed && ifaceNamed.IsGenericType &&
                ifaceNamed.ConstructedFrom.Name == "IDictionary" &&
                ifaceNamed.ConstructedFrom.ContainingNamespace.ToDisplayString() == "System.Collections.Generic")
            {
                keyType = ifaceNamed.TypeArguments[0];
                valueType = ifaceNamed.TypeArguments[1];
                return true;
            }
        }

        if (unwrapped is INamedTypeSymbol named && named.IsGenericType &&
            named.ConstructedFrom.Name == "Dictionary" &&
            named.ConstructedFrom.ContainingNamespace.ToDisplayString() == "System.Collections.Generic")
        {
            keyType = named.TypeArguments[0];
            valueType = named.TypeArguments[1];
            return true;
        }

        return false;
    }

    private sealed class ModelInfo
    {
        public ModelInfo(INamedTypeSymbol type)
        {
            Type = type;
            Properties = new List<MemberInfo>();
            Fields = new List<MemberInfo>();
        }

        public INamedTypeSymbol Type { get; }

        public List<MemberInfo> Properties { get; }

        public List<MemberInfo> Fields { get; }
    }

    private sealed class MemberInfo
    {
        public MemberInfo(IPropertySymbol symbol, string baseName, string defaultKey)
        {
            Symbol = symbol;
            MemberName = symbol.Name;
            MemberType = symbol.Type;
            BaseName = baseName;
            DefaultKey = defaultKey;
            IsField = false;
            CanWrite = symbol.SetMethod is not null;
            HasGetter = symbol.GetMethod is not null;
        }

        public MemberInfo(IFieldSymbol symbol, string baseName, string defaultKey)
        {
            Symbol = symbol;
            MemberName = symbol.Name;
            MemberType = symbol.Type;
            BaseName = baseName;
            DefaultKey = defaultKey;
            IsField = true;
            CanWrite = !symbol.IsReadOnly && !symbol.IsConst;
            HasGetter = true;
        }

        public ISymbol Symbol { get; }

        public string MemberName { get; }

        public ITypeSymbol MemberType { get; }

        public string BaseName { get; }

        public string DefaultKey { get; }

        public bool IsField { get; }

        public bool CanWrite { get; }

        public bool HasGetter { get; }
    }
}
